// Code generated by GoJay. DO NOT EDIT.

package benchmark

import "github.com/francoispqt/gojay"
import "time"

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *CBPerson) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "name":
		if v.Name == nil {
			v.Name = &CBName{}
		}
		return dec.Object(v.Name)
	case "github":
		if v.Github == nil {
			v.Github = &CBGithub{}
		}
		return dec.Object(v.Github)
	case "gravatar":
		if v.Gravatar == nil {
			v.Gravatar = &CBGravatar{}
		}
		return dec.Object(v.Gravatar)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *CBPerson) NKeys() int { return 3 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *CBPerson) MarshalJSONObject(enc *gojay.Encoder) {
	enc.ObjectKey("name", v.Name)
	enc.ObjectKey("github", v.Github)
	enc.ObjectKey("gravatar", v.Gravatar)
}

// IsNil returns wether the structure is nil value or not
func (v *CBPerson) IsNil() bool { return v == nil }

// apparently we can't directly decode an array, so wrap it so we can do it
type myMaintainersArray []*Maintainer

func (v *myMaintainersArray) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = Maintainer{}
	if err := dec.Object(&s); err != nil {
		return err
	}
	*v = append(*v, &s)
	return nil
}

func (v *myMaintainersArray) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.Object(s)
	}
}

func (v *myMaintainersArray) IsNil() bool {
	return *v == nil || len(*v) == 0
}

// apparently we can't directly decode an array, so wrap it so we can do it
type myStringArray []string

func (v *myStringArray) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = ""
	if err := dec.String(&s); err != nil {
		return err
	}
	*v = append(*v, s)
	return nil
}

func (v *myStringArray) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.String(s)
	}
}

func (v *myStringArray) IsNil() bool {
	return *v == nil || len(*v) == 0
}

// apparently we can't directly decode a map, so wrap it so we can do it
type myStringMap map[string]string

func (m myStringMap) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	s := ""
	err := dec.String(&s)
	if err != nil {
		return err
	}
	m[k] = s
	return nil
}

func (m myStringMap) NKeys() int { return 0 }

func (m myStringMap) MarshalJSONObject(enc *gojay.Encoder) {
	for k, v := range m {
		enc.StringKey(k, v)
	}
}

func (m myStringMap) IsNil() bool { return m == nil || len(m) == 0 }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *ChartVersion) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "name":
		return dec.String(&v.Name)
	case "home":
		return dec.String(&v.Home)
	case "sources":
		sources := myStringArray(make([]string, 0))
		err := dec.Array(&sources)
		if err != nil {
			return err
		}
		v.Sources = sources
	case "version":
		return dec.String(&v.Version)
	case "description":
		return dec.String(&v.Description)
	case "keywords":
		keywords := myStringArray(make([]string, 0))
		err := dec.Array(&keywords)
		if err != nil {
			return err
		}
		v.Keywords = keywords
	case "maintainers":
		maints := myMaintainersArray(make([]*Maintainer, 0))
		err := dec.Array(&maints)
		if err != nil {
			return err
		}
		v.Maintainers = maints
	case "engine":
		return dec.String(&v.Engine)
	case "icon":
		return dec.String(&v.Icon)
	case "apiVersion":
		return dec.String(&v.ApiVersion)
	case "condition":
		return dec.String(&v.Condition)
	case "tags":
		return dec.String(&v.Tags)
	case "appVersion":
		return dec.String(&v.AppVersion)
	case "deprecated":
		return dec.Bool(&v.Deprecated)
	case "tillerVersion":
		return dec.String(&v.TillerVersion)
	case "annotations":
		annots := myStringMap(make(map[string]string))
		err := dec.Object(annots)
		if err != nil {
			return err
		}
		v.Annotations = annots
	case "kubeVersion":
		return dec.String(&v.KubeVersion)
	case "urls":
		urls := myStringArray(make([]string, 0))
		err := dec.Array(&urls)
		if err != nil {
			return err
		}
		v.URLs = urls
	case "created":
		return dec.Time(&v.Created, time.RFC3339Nano)
	case "removed":
		return dec.Bool(&v.Removed)
	case "digest":
		return dec.String(&v.Digest)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *ChartVersion) NKeys() int { return 21 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *ChartVersion) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("name", v.Name)
	enc.StringKey("home", v.Home)
	srcs := myStringArray(v.Sources)
	enc.ArrayKey("sources", &srcs)
	enc.StringKey("version", v.Version)
	enc.StringKey("description", v.Description)
	kwds := myStringArray(v.Keywords)
	enc.ArrayKey("keywords", &kwds)
	mnts := myMaintainersArray(v.Maintainers)
	enc.ArrayKey("maintainers", &mnts)
	enc.StringKey("engine", v.Engine)
	enc.StringKey("icon", v.Icon)
	enc.StringKey("apiVersion", v.ApiVersion)
	enc.StringKey("condition", v.Condition)
	enc.StringKey("tags", v.Tags)
	enc.StringKey("appVersion", v.AppVersion)
	enc.BoolKey("deprecated", v.Deprecated)
	enc.StringKey("tillerVersion", v.TillerVersion)
	enc.ObjectKey("annotations", myStringMap(v.Annotations))
	enc.StringKey("kubeVersion", v.KubeVersion)
	urls := myStringArray(v.URLs)
	enc.ArrayKey("urls", &urls)
	enc.TimeKey("created", &v.Created, time.RFC3339Nano)
	enc.BoolKey("removed", v.Removed)
	enc.StringKey("digest", v.Digest)
}

// IsNil returns wether the structure is nil value or not
func (v *ChartVersion) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *CBName) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "fullName":
		return dec.String(&v.FullName)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *CBName) NKeys() int { return 1 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *CBName) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("fullName", v.FullName)
}

// IsNil returns wether the structure is nil value or not
func (v *CBName) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *DSTopic) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "id":
		return dec.Int(&v.Id)
	case "slug":
		return dec.String(&v.Slug)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *DSTopic) NKeys() int { return 2 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *DSTopic) MarshalJSONObject(enc *gojay.Encoder) {
	enc.IntKey("id", v.Id)
	enc.StringKey("slug", v.Slug)
}

// IsNil returns wether the structure is nil value or not
func (v *DSTopic) IsNil() bool { return v == nil }

// apparently we can't directly decode an array, so wrap it so we can do it
type myUsersArray []*DSUser

func (v *myUsersArray) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = DSUser{}
	if err := dec.Object(&s); err != nil {
		return err
	}
	*v = append(*v, &s)
	return nil
}

func (v *myUsersArray) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.Object(s)
	}
}

func (v *myUsersArray) IsNil() bool {
	return *v == nil || len(*v) == 0
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *LargePayload) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "topics":
		if v.Topics == nil {
			v.Topics = &DSTopicsList{}
		}
		return dec.Object(v.Topics)
	case "users":
		users := myUsersArray(make([]*DSUser, 0))
		err := dec.Array(&users)
		if err != nil {
			return err
		}
		v.Users = users
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *LargePayload) NKeys() int { return 2 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *LargePayload) MarshalJSONObject(enc *gojay.Encoder) {
	usrs := myUsersArray(v.Users)
	enc.ArrayKey("users", &usrs)
	enc.ObjectKey("topics", v.Topics)
}

// IsNil returns wether the structure is nil value or not
func (v *LargePayload) IsNil() bool { return v == nil }

// apparently we can't directly decode a map, so wrap it so we can do it
type myEntriesMap map[string]ChartVersions

func (m myEntriesMap) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	s := ChartVersions(make([]ChartVersion, 0))
	err := dec.AddArray(&s)
	if err != nil {
		return err
	}
	m[k] = s
	return nil
}

func (m myEntriesMap) NKeys() int { return 0 }

func (m myEntriesMap) MarshalJSONObject(enc *gojay.Encoder) {
	for k, v := range m {
		enc.AddArrayKey(k, &v)
	}
}

func (m myEntriesMap) IsNil() bool { return m == nil || len(m) == 0 }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *IndexFile) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "apiVersion":
		return dec.String(&v.APIVersion)
	case "generated":
		return dec.Time(&v.Generated, time.RFC3339Nano)
	case "entries":
		ent := myEntriesMap(make(map[string]ChartVersions))
		err := dec.Object(ent)
		if err != nil {
			return err
		}
		v.Entries = ent
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *IndexFile) NKeys() int { return 3 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *IndexFile) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("apiVersion", v.APIVersion)
	enc.TimeKey("generated", &v.Generated, time.RFC3339Nano)
	enc.ObjectKey("entries", myEntriesMap(v.Entries))
}

// IsNil returns wether the structure is nil value or not
func (v *IndexFile) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *Maintainer) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "name":
		return dec.String(&v.Name)
	case "email":
		return dec.String(&v.Email)
	case "url":
		return dec.String(&v.Url)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *Maintainer) NKeys() int { return 3 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *Maintainer) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("name", v.Name)
	enc.StringKey("email", v.Email)
	enc.StringKey("url", v.Url)
}

// IsNil returns wether the structure is nil value or not
func (v *Maintainer) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *SmallPayload) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "st":
		return dec.Int(&v.St)
	case "sid":
		return dec.Int(&v.Sid)
	case "tt":
		return dec.String(&v.Tt)
	case "gr":
		return dec.Int(&v.Gr)
	case "uuid":
		return dec.String(&v.Uuid)
	case "ip":
		return dec.String(&v.Ip)
	case "ua":
		return dec.String(&v.Ua)
	case "tz":
		return dec.Int(&v.Tz)
	case "v":
		return dec.Int(&v.V)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *SmallPayload) NKeys() int { return 9 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *SmallPayload) MarshalJSONObject(enc *gojay.Encoder) {
	enc.IntKey("st", v.St)
	enc.IntKey("sid", v.Sid)
	enc.StringKey("tt", v.Tt)
	enc.IntKey("gr", v.Gr)
	enc.StringKey("uuid", v.Uuid)
	enc.StringKey("ip", v.Ip)
	enc.StringKey("ua", v.Ua)
	enc.IntKey("tz", v.Tz)
	enc.IntKey("v", v.V)
}

// IsNil returns wether the structure is nil value or not
func (v *SmallPayload) IsNil() bool { return v == nil }

// apparently we can't directly decode an array, so wrap it so we can do it
type myAvatarsArray []*CBAvatar

func (v *myAvatarsArray) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = CBAvatar{}
	if err := dec.Object(&s); err != nil {
		return err
	}
	*v = append(*v, &s)
	return nil
}

func (v *myAvatarsArray) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.Object(s)
	}
}

func (v *myAvatarsArray) IsNil() bool {
	return *v == nil || len(*v) == 0
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *CBGravatar) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "avatars":
		avatars := myAvatarsArray(make([]*CBAvatar, 0))
		err := dec.Array(&avatars)
		if err != nil {
			return err
		}
		v.Avatars = avatars
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *CBGravatar) NKeys() int { return 1 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *CBGravatar) MarshalJSONObject(enc *gojay.Encoder) {
	avts := myAvatarsArray(v.Avatars)
	enc.ArrayKey("avatars", &avts)
}

// IsNil returns wether the structure is nil value or not
func (v *CBGravatar) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *CBGithub) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "followers":
		return dec.Int(&v.Followers)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *CBGithub) NKeys() int { return 1 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *CBGithub) MarshalJSONObject(enc *gojay.Encoder) {
	enc.IntKey("followers", v.Followers)
}

// IsNil returns wether the structure is nil value or not
func (v *CBGithub) IsNil() bool { return v == nil }

// apparently we can't directly decode a map, so wrap it so we can do it
type myCompanyMap map[string]interface{}

func (m myCompanyMap) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	var s interface{} = nil
	err := dec.AddInterface(&s)
	if err != nil {
		return err
	}
	m[k] = s
	return nil
}

func (m myCompanyMap) NKeys() int { return 0 }

func (m myCompanyMap) MarshalJSONObject(enc *gojay.Encoder) {
	for k, v := range m {
		enc.AddInterfaceKey(k, &v)
	}
}

func (m myCompanyMap) IsNil() bool { return m == nil || len(m) == 0 }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *MediumPayload) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "person":
		if v.Person == nil {
			v.Person = &CBPerson{}
		}
		return dec.Object(v.Person)
	case "company":
		com := myCompanyMap(make(map[string]interface{}))
		err := dec.Object(com)
		if err != nil {
			return err
		}
		v.Company = com
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *MediumPayload) NKeys() int { return 2 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *MediumPayload) MarshalJSONObject(enc *gojay.Encoder) {
	enc.ObjectKey("person", v.Person)
	enc.ObjectKey("company", myCompanyMap(v.Company))
}

// IsNil returns wether the structure is nil value or not
func (v *MediumPayload) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *CBAvatar) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "url":
		return dec.String(&v.Url)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *CBAvatar) NKeys() int { return 1 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *CBAvatar) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("url", v.Url)
}

// IsNil returns wether the structure is nil value or not
func (v *CBAvatar) IsNil() bool { return v == nil }

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *DSUser) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "username":
		return dec.String(&v.Username)
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *DSUser) NKeys() int { return 1 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *DSUser) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKey("username", v.Username)
}

// IsNil returns wether the structure is nil value or not
func (v *DSUser) IsNil() bool { return v == nil }

// apparently we can't directly decode an array, so wrap it so we can do it
type myTopicsArray []*DSTopic

func (v *myTopicsArray) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = DSTopic{}
	if err := dec.Object(&s); err != nil {
		return err
	}
	*v = append(*v, &s)
	return nil
}

func (v *myTopicsArray) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.Object(s)
	}
}

func (v *myTopicsArray) IsNil() bool {
	return *v == nil || len(*v) == 0
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (v *DSTopicsList) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {
	switch k {
	case "moreTopicsUrl":
		return dec.String(&v.MoreTopicsUrl)
	case "topics":
		topics := myTopicsArray(make([]*DSTopic, 0))
		err := dec.Array(&topics)
		if err != nil {
			return err
		}
		v.Topics = topics
	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (v *DSTopicsList) NKeys() int { return 2 }

// MarshalJSONObject implements gojay's MarshalerJSONObject
func (v *DSTopicsList) MarshalJSONObject(enc *gojay.Encoder) {
	tpcs := myTopicsArray(v.Topics)
	enc.ArrayKey("topics", &tpcs)
	enc.StringKey("moreTopicsUrl", v.MoreTopicsUrl)
}

// IsNil returns wether the structure is nil value or not
func (v *DSTopicsList) IsNil() bool { return v == nil }

// UnmarshalJSONArray implements gojay's UnmarshalerJSONArray
func (v *ChartVersions) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var s = ChartVersion{}
	if err := dec.Object(&s); err != nil {
		return err
	}
	*v = append(*v, s)
	return nil
}

// MarshalJSONArray implements gojay's MarshalerJSONArray
func (v *ChartVersions) MarshalJSONArray(enc *gojay.Encoder) {
	for _, s := range *v {
		enc.Object(&s)
	}
}

// IsNil implements gojay's MarshalerJSONArray
func (v *ChartVersions) IsNil() bool {
	return *v == nil || len(*v) == 0
}
